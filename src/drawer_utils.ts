import { CapacityBottleneck } from "./augmenters/base_augmenter";

const TOLERANCE = 4;
const PLOT_THRESHOLD_OFFSET = 1;
const EPSILON = Math.pow(10, -1 * TOLERANCE);

export function float_isclose(x: number, y: number): boolean {
  // compare their string reprs, rounded
  return Math.abs(x - y) <= EPSILON;
}

/**
 * This class encapsulates a point in the time-space plane, determined by a time and position value. Supports comparisons and slope computations.
 *
 * @export
 * @class dtPoint
 */
export class dtPoint {
  public time: number;
  public position: number;

  /**
     * Creates an instance of dtPoint.
     * 
     * @param {number} time time of the point
     * @param {number} position position of the point
     * @memberof dtPoint
     */
  constructor(time: number, position: number) {
    this.time = time;
    this.position = position;
  }

  public toArray(): [number, number] {
    return [this.time, this.position];
  }

  /**
     * Determines whether two dtPoint objects resolve ot the same point in time-space plane.
     * 
     * @param other point to compare with
     * @returns whether or not the two points are equivalence, up to floating point error
     */
  public equalTo(other: dtPoint): boolean {
    return float_isclose(this.time, other.time) && float_isclose(this.position, other.position);
  };

  /**
     * Calculates the slope between two dtPoints. Fails if the two points hsare a common time, as the slope in that case is undefined.
     *
     * @param {dtPoint} other
     * @return {number}  slope between this point and the other, rise over run
     * @memberof dtPoint
     */
  public getSlope(other: dtPoint): number {
    if (float_isclose(this.time, other.time)) {
      throw new Error("the points do not have a well-defined slope, as they share a time");
    }

    // slope formula
    return (this.position - other.position) / (this.time - other.time);
  }

  public toString(): string {
    return `(${this.time.toFixed(TOLERANCE)}, ${this.position.toFixed(TOLERANCE)})`;
  }

  /**
     * Clones the dtPoint, returning a new, distinct copy of the point that is equivalent.
     *
     * @return {dtPoint} cloned dtPoint
     * @memberof dtPoint
     */
  public clone(): dtPoint {
    return new dtPoint(this.time, this.position);
  }

}

/**
 * This enum represents the types that an event that occurs in the shockwave drawer process can be. 
 *
 * @enum {number}
 */
export enum EventType {
    // eslint-disable-next-line no-unused-vars
    intersection = 1, // intersection between non-user interfaces
    // eslint-disable-next-line no-unused-vars
    capacity = 2,  // generated by the user-interfaces; represents some change in capacity in the time-space plane
    // eslint-disable-next-line no-unused-vars
    truncation = 3,  // intersection that involves some user interface
}

/**
 * This class represents is the base class for all events, which are things that occur during the shockwave drawing procses, creating interfaces as they occur. At its base, it is determined by the point at which the event occurs and the type of event it is.
 *
 * @abstract
 * @class Event
 */
export abstract class Event {
  public point: dtPoint;
  public type: EventType;

  // whether or not the event is disabled; currently unused
  public disabled = false;

  /**
     * Creates an instance of Event.
     * 
     * @param {dtPoint} point point of the event
     * @param {EventType} type type of the event
     * @memberof Event
     */
  constructor(point: dtPoint, type: EventType) {
    this.point = point;
    this.type = type;
  }

  /**
     * Defines the equality between two events. Two events are equal if and only if the two events share a point and a type.
     *
     * @param {Event} other
     * @return {boolean``} 
     * @memberof Event
     */
  public equalTo(other: Event): boolean {
    return this.point.equalTo(other.point) && this.type === other.type;
  }

  /**
     * Defines how events can be ordered in the shockwave drawer event queue, which determines the order in which events are processed. This is solely determined by the time of the events--events are processed chronologically, with some caveats.
     *
     * @param {Event} other
     * @return {number} negative if LHS is first; zero if equal; positive if LHS is second
     * @static
     * @memberof Event
     */
  public static compareTo(x: Event, y: Event): number {
    return y.point.time - x.point.time;
  }
}

/**
 * Specialization of event to intersection events--intersections between interfaces not involving user interfaces. Adds a list of interfaces to the members, which define what interfaces are intersecting.
 *
 * @export
 * @class IntersectionEvent
 * @extends {Event}
 */
export class IntersectionEvent extends Event {
  public interfaces: DiagramInterface[];

  constructor(point: dtPoint, interfaces: DiagramInterface[]) {
    super(point, EventType.intersection);

    for (const diagram_interface of interfaces) {
      if (diagram_interface instanceof UserInterface) {
        throw new TypeError("The interfaces of an intersection event cannot include user interfaces");
      }
    }

    // TODO: determine if we can just set arrays equal to each other without suffering from some aliasing errors
    this.interfaces = interfaces;
  }
}

/**
 * Specialization of event for capacity events, which are events created by user-interfaces. These define a generic change in capacity in the time-space diagram. 
 * 
 * Adds members to capture the change in capacity (before and after capacity) and a member to capture the user interface this capacity event applies to.
 *
 * @export
 * @class CapacityEvent
 * @extends {Event}
 */
export class CapacityEvent extends Event {
  public prior_capacity: number;
  public posterior_capacity: number;
  public user_interface: UserInterface;

  /**
     * Creates an instance of CapacityEvent.
     * @param {dtPoint} point point at which the event takes place
     * @param {UserInterface} user_interface user interface that the event applies to
     * @param {number} [prior_capacity=-1] capacity before the event
     * @param {number} [posterior_capacity=-1] capacity after the event (which is the key property of a CapacityEvent)
     * @memberof CapacityEvent
     */
  constructor (
    point: dtPoint, 
    user_interface: UserInterface, 
    prior_capacity = -1, 
    posterior_capacity = -1
  ) {
    super(point, EventType.capacity);

    if (prior_capacity < 0 && prior_capacity != -1) {
      throw new RangeError("Prior capacity must be positive or -1 (for determination at runtime)");
    }

    if (posterior_capacity < 0 && posterior_capacity != -1 ) {
      throw new RangeError("Posterior capacity must be positive or -1 (for determination at runtime)");
    }

    this.prior_capacity = prior_capacity;
    this.posterior_capacity = posterior_capacity;
    this.user_interface = user_interface;
  }
}

/**
 * Specialization of events to TruncationEvents. These describe the intersection of any number of generic interfaces with ONE user interface. 
 * 
 * Adds member variables to record the user interface of the event and the list of generic interfaces.
 *
 * @export
 * @class TruncationEvent
 * @extends {Event}
 */
export class TruncationEvent extends Event {
  public user_interface: UserInterface;
  public interfaces: DiagramInterface[];
    
  /**
     * Creates an instance of TruncationEvent.
     * 
     * @param {dtPoint} point the point of the truncation event
     * @param {UserInterface} user_interface the user interface of the truncation event
     * @param {DiagramInterface[]} interfaces the interfaces intersecting with the user interface at the provided point
     * @memberof TruncationEvent
     */
  constructor (point: dtPoint, user_interface: UserInterface, interfaces: DiagramInterface[]) {
    super(point, EventType.truncation);

    this.user_interface = user_interface;
        
    // verify no interfaces are user interfaces
    for (const diagram_interface of interfaces) {
      if (diagram_interface instanceof UserInterface) {
        throw new TypeError("Interfaces of a truncation event's interface list cannot be UserInterfaces");
      }
    }

    this.interfaces = interfaces;
  }
}

/**
 * This class encapsulates a state in the partition of the time-space shockwave diagram. A state is uniquely determined by the density and flow of cars in the state.
 *
 * @export
 * @class State
 */
export class State {
  public density: number;
  public flow: number;

  /**
     * Creates an instance of State.
     * 
     * @param {number} density density of the state
     * @param {number} flow flow of the state
     * @memberof State
     */
  constructor(density: number, flow: number) {
    this.density = density;
    this.flow = flow;
  }

  /**
     * Calculates the slope between two states, as we would expect them to have in the fundamental diagram. 
     *
     * @param {State} other state to get the slope with
     * @return {number}
     * @memberof State slope between this and other
     */
  public getInterfaceSlope(other: State): number {
    if (float_isclose(this.density, other.density)) {
      throw new RangeError("The slope being calculated is not well-defined, as the two states share a density");
    }

    // slope formula
    return (this.flow - other.flow) / (this.density - other.density);
  }

  /**
     * Computes the slope between this state and the point (0, 0) on the fundamental diagram.
     *
     * @return {number} resultant slope
     * @memberof State
     */
  public getSlope(): number {
    if (this.density === 0) {
      return Infinity;
    }

    // slope formula but one point is (0, 0)
    return this.flow / this.density;
  }

  /**
     * Defines equality between states. Two states are equal if and only if they share a density and a flow--they resolve to the same point on the fundamental diagram.
     *
     * @param {State} other state to compare with
     * @return {boolean} whether or not the states are equivalent
     * @memberof State
     */
  public equalTo(other: State): boolean {
    return float_isclose(this.density, other.density) && float_isclose(this.flow, other.flow);
  }

  public toString(): string {
    return `(${this.density.toFixed(TOLERANCE)}, ${this.flow.toFixed(TOLERANCE)})`;
  }

  public clone(): State {
    return new State(this.density, this.flow);
  }
}

/**
 * This class encapsulates the idea of an interface in the dt-space. In particular, an interface is a linear boundary between two states in the dt-space. This linear boundary is fully defined by a point and a slope. 
 * 
 * The above/below states refer ot hte state directly above/below (in y) the interface in the typical 2d-space coordinate plane directionality. Greater positions are greater ys; greater times are greater xs.
 * 
 * The bounds define the endpoint. The first bound is the lower bound and the second is the upper bound in terms of the time-extent of the interface in dt-space. Bounds need not be well-defined.
 * 
 * Not applicable to vertical interfaces.
 *
 * @export
 * @class DiagramInterface
 */
export class DiagramInterface {
  public point: dtPoint;
  public slope: number;
  public above: State | undefined;
  public below: State | undefined;
  public lower_bound: dtPoint;
  public upper_bound: dtPoint;

  /**
     * Creates an instance of DiagramInterface.
     * 
     * @param {dtPoint} point representative point of the interface
     * @param {number} slope slope of the interface
     * @param {State} [above] state above the interface (downstream in position)
     * @param {State} [below] state below the interface (upstream in position)
     * @param {dtPoint} [lower_bound] lower bound of the interface; if not provided, is interpolated using the lower time bound & the provided point/slopoe
     * @param {dtPoint} [upper_bound] upper bound of the interface; if not provided is set to Infinity, Infinity as a placeholder
     * @memberof DiagramInterface
     */
  constructor(
    point: dtPoint, 
    slope: number, 
    above?: State, 
    below?: State, 
    lower_bound?: dtPoint, 
    upper_bound?: dtPoint
  ) {
    this.point = point;
    this.slope = slope;
    this.above = above;
    this.below = below;

    // lower bound & upper bound interpolation if undefined
    if (lower_bound === undefined) {
      this.lower_bound = new dtPoint(
        -1 * PLOT_THRESHOLD_OFFSET, 
        point.position - slope * point.time - PLOT_THRESHOLD_OFFSET * slope
      );
    } else {
      this.lower_bound = lower_bound;
    }

    if (upper_bound === undefined) {
      this.upper_bound = new dtPoint(Infinity, Infinity);
    } else {
      this.upper_bound = upper_bound;
    }
  }

  /**
     * Sets the above state of the interface. Enforces coherency if already set; otherwise, just sets it.
     *
     * @param {State} state state to set as above state
     * @memberof DiagramInterface
     */
  public setAboveState(state: State): void {
    if (this.above !== undefined) {
      // TODO: what to do here again? originally checked for state coherency
    } else {
      this.above = state;
    }
  }

  /**
     * Sets the below state of the interfaces. Enforces coherency if already set; otherwise, just sets it.
     *
     * @param {State} state state to set as the below state
     * @memberof DiagramInterface
     */
  public setBelowState(state: State): void {
    if (this.below !== undefined ) {
      // see above
    } else {
      this.below = state;
    }
  }

  /**
     * Checks if this interface has the given point as an endpoint. Endpoints must be defined to be considered.
     *
     * @param {dtPoint} point
     * @return {boolean} whether or not {point} is an endpoint of this interface
     * @memberof DiagramInterface
     */
  public hasEndpoint(point: dtPoint): boolean {
    if (this.lower_bound?.equalTo(point)) {
      return true;
    }
        
    if (this.upper_bound?.equalTo(point)) {
      return true;
    }

    return false;
  }

  /**
     * This function gets the position of an interface at a given time, if the interface is defined there. Uses the fact that interfaces are linear. 
     *
     * @param {number} time time to get the position for
     * @return {(number | undefined)} the corresponding position, or undefined if it does not exist
     * @memberof DiagramInterface
     */
  public getPosAtTime(time: number): number | undefined {
    // floating ponit checks to just return endpoints if that is what is being requested
    if (float_isclose(this.lower_bound.time, time)) {
      return this.lower_bound.position;
    } 
    if (float_isclose(this.upper_bound.time, time)) {
      return this.upper_bound.position;
    }

    // check if the two lines are completely disjoint -- return undefined
    if ((this.upper_bound.time < time) || (this.lower_bound.time > time)) {
      return undefined;
    }

    // basic linear interpolation
    return this.point.position + this.slope * (time - this.point.time);
  }

  /**
     * This function resolves the intersection between this interface and a provided interface as a dtPoint, if it exists. Has robust edge case handling for parallel lines & different endpoint ranges.
     *
     * @param {DiagramInterface} other interface to compute intersection for
     * @return {(dtPoint | undefined)} intersection point or undefined if there is none
     * @memberof DiagramInterface
     */
  public intersection(other: DiagramInterface): dtPoint | undefined {
    // find a time at which we can reasonably assume that both lines are defined there
    // use this time later for robust edge case checking/sanity checks for whether we should continue to find an intersection
    let mid_time: number;
    if (this.upper_bound.time === Infinity || other.upper_bound.time == Infinity) {
      mid_time = Math.max(this.lower_bound.time, other.lower_bound.time) + 1;
    } else {
      if (
        Math.abs(this.upper_bound.time - other.lower_bound.time) < 
        Math.abs(this.lower_bound.time - other.upper_bound.time)
      ) {
        mid_time = (this.upper_bound.time + other.lower_bound.time) / 2;
      } else {
        mid_time = (this.lower_bound.time + other.upper_bound.time) / 2;
      }
    }

    // get position at that mid time
    let pos1: number | undefined = this.getPosAtTime(mid_time);
    let pos2: number | undefined = other.getPosAtTime(mid_time);

    // check for identical interfaces--this would only happen if two interfaces are overlapping
    // i.e., this checks for the same slope && not parallel--intersecting
    if (
      float_isclose(this.slope, other.slope)
        && pos1 !== undefined
        && pos2 !== undefined
        && float_isclose(pos1, pos2)
    ) {
      throw new Error("checking interseciton between identical interfaces -- i.e., have equivalent interfaces, which should not be the case");
      // otherwise, the two interfaces are just parallel and have no intersection -- return undefined
    } else if (float_isclose(this.slope, other.slope)) {
      return undefined;
    }

    // now do the actual intersection checking, which is now guaranteed to be well-defined

    // this is a direct read-off of the formula for an intersection point (x) given two lines in point-slope form
    const timeOfIntersection: number = (
      (other.point.position - other.slope * other.point.time 
      - this.point.position + this.slope * this.point.time) 
      / (this.slope - other.slope)
    );

    // get the positions at the hypothetical time of intersection
    pos1 = this.getPosAtTime(timeOfIntersection);
    pos2 = other.getPosAtTime(timeOfIntersection);

    // if either interface is undefined at that point there is no intersection
    if ((pos1 === undefined) || (pos2 === undefined)) {
      return undefined;
    }

    // sanity check
    if (!float_isclose(pos1, pos2)) {
      throw new Error("The intersection logic failed");
    }

    return new dtPoint(timeOfIntersection, pos1);
  }

  /**
     * Adds a lower/upper cutoff to this interface's bounds, handling floating point errors and any existing bounds.
     *
     * @param {dtPoint} [lower] new lower bound to add
     * @param {dtPoint} [upper] new upper bound to add
     * @memberof DiagramInterface
     */
  public addCutoff(lower?: dtPoint, upper?: dtPoint): void {
    // don't do anything if the interface already has these endpoints
    // (handle floating point errors)
    if ((lower !== undefined && this.hasEndpoint(lower))) {
      lower = undefined;
    }
    if ((upper !== undefined) && this.hasEndpoint(upper)) {
      upper = undefined;
    }

    // if nothing is being set, don't do anything
    if (lower === undefined && upper === undefined) {
      return; 
    }

    // error checking for argument validity -- the provided endpoints must be coherent with the interface definition
    if (lower !== undefined && !float_isclose(this.slope, this.point.getSlope(lower))) {
      throw new RangeError("The lower bound supplied is invalid--it does not fall along the interface line");
    }
    
    if (upper !== undefined && !float_isclose(this.slope, this.point.getSlope(upper))) {
      throw new RangeError("The upper bound supplied is invalid--it does not fall along the interface line");
    }

    // make sure that the representative point of an interface is alwasy in-bounds
    if (lower === undefined) {
      // know upper is not undefined from check for double undefined-ness earlier
      this.point = upper!; 
    } else {
      this.point = lower;
    }

    // actually set the endpoints if they are more restrictive
    if (lower !== undefined) {
      if (this.lower_bound.time < lower.time) {
        this.lower_bound = lower;
      }
    }

    if (upper !== undefined) {
      if (this.upper_bound.time > upper.time) {
        this.upper_bound = upper;
      }
    }
  }

  /**
     * This function determines whether or not two interfaces are functionally equivalent--i.e., delinate the the same thing in the same part of the 2d space
     *
     * @param {DiagramInterface} other interface to compare with
     * @return {boolean} whether or not the two interfaces are functionally equivalent
     * @memberof DiagramInterface
     */
  public equivalentTo(other: DiagramInterface): boolean { 
    // if the two interfaces delineate different state combinations, they are not equivalent
    if (
      (other.below !== undefined && this.below !== undefined && !other.below.equalTo(this.below)) 
      || (other.above !== undefined && this.above !== undefined && !other.above.equalTo(this.above))
    ) {
      return false;
    }

    // if the two interfaces are disjoint in terms of endpoints, they are not equivalent
    if (
      !float_isclose(other.upper_bound.time, this.upper_bound.time) 
        || !float_isclose(other.lower_bound.time, this.lower_bound.time)
    ) {
      return false;
    }

    // if the two interfaces share a point, they are equivalent if they share a slope
    if (other.point.equalTo(this.point)) {
      return float_isclose(other.slope, this.slope);
    }

    // if the two interfaces share a time, they are equivalent if they share a position and a slope
    // this case prevents getting an undefined slope
    if (float_isclose(other.point.time, this.point.time)) {
      return (
        float_isclose(other.point.position, this.point.position) 
        && float_isclose(this.slope, other.slope)
      );
    }

    // otherwise the two interfaces are equivalent if the slope between the representative points is consistent with their slopes
    return (float_isclose(this.point.getSlope(other.point), other.slope) 
    && float_isclose(other.slope, this.slope));
  }

  /**
     * Returns whether or not an interface is user-generated. For the base class, just returns false.
     *
     * @return {boolean} whether or not this interface is user generated
     * @memberof DiagramInterface
     */
  public isUserGenerated(): boolean {
    return false;
  }

  /**
     * Computes the slope of the interface--i.e., computes this.slope but organically.
     *
     * @return {number}
     * @memberof DiagramInterface
     */
  public getSlope(): number {
    if (this.upper_bound.time === Infinity) {
      throw new EvalError("Interface does not have well-defined endpoints");
    }

    return this.upper_bound.getSlope(this.lower_bound);
  }

  /**
     * Returns whether or not this interface has well-defined above/below states--i.e., whether or not they are both not undefined.
     *
     * @return {boolean} whether or not both the above/below state are both not undefined
     * @memberof DiagramInterface
     */
  public hasValidStates(): boolean {
    return this.above !== undefined && this.below !== undefined;
  }

  public clone(): DiagramInterface {
    return new DiagramInterface(
      this.point.clone(),
      this.slope,
      this.above ? this.above.clone() : undefined,
      this.below ? this.below.clone() : undefined,
      this.lower_bound ? this.lower_bound.clone() : undefined,
      this.upper_bound ? this.upper_bound.clone(): undefined
    );
  }
}

/**
 * Specialization of diagram interface for user interfaces, which define capacity bottlenecks and which are determined by the user.
 * 
 * Adds member variables to keep track of the original upper/lower bounds for drawing purposes and records the augment this interface pertains to. 
 * 
 * Also returns true on isUserGenerated.
 *
 * @export
 * @class UserInterface
 * @extends {DiagramInterface}
 */
export class UserInterface extends DiagramInterface {

  public augment: CapacityBottleneck;
  public original_lower_bound: dtPoint;
  public original_upper_bound: dtPoint;

  /**
     * Creates an instance of UserInterface.
     * 
     * @param {dtPoint} point point of the interface
     * @param {number} slope slope of the interface
     * @param {CapacityBottleneck} augment the augment that "created" this interface
     * @param {dtPoint} lower_bound lower bound of the interface w.r.t. time
     * @param {dtPoint} upper_bound upper bound of the interface w.r.t. time
     * @memberof UserInterface
     */
  constructor(
    point: dtPoint, 
    slope: number, 
    augment: CapacityBottleneck, 
    lower_bound: dtPoint, 
    upper_bound: dtPoint
  ) {
    super(point, slope, undefined, undefined, lower_bound, upper_bound);

    this.augment = augment;
    this.original_lower_bound = lower_bound.clone();
    this.original_upper_bound = upper_bound.clone();
  }

  /**
     * Overrides the parent class version. Returns true.
     *
     * @return {boolean} whether or not this interface is user generated
     */
  public isUserGenerated(): boolean {
    return true;
  }

  public clone(): UserInterface {
    const temp: UserInterface = super.clone() as UserInterface;
    temp.augment = this.augment;
    temp.original_lower_bound = this.original_lower_bound;
    temp.original_upper_bound = this.original_upper_bound;

    return temp;
  }
}

/**
 * Essentially a dummy version of a typical interface, solely used for plotting trajectories. Ignores the above/below states recorded in a typical interface.
 *
 * @export
 * @class Trajectory
 * @extends {DiagramInterface}
 */
export class Trajectory extends DiagramInterface {
  constructor(point: dtPoint, slope: number, lower_bound?: dtPoint, upper_bound?: dtPoint) {
    super(point, slope, undefined, undefined, lower_bound, upper_bound);
  }
}

export interface FixedTimeComparable {
    priority: number,
    position: number,
    event: Event
}

export function compareFixedTimeComparable(x: FixedTimeComparable, y: FixedTimeComparable): number {
  if (x.priority == y.priority) {
    return -1 * (x.position - y.position);
  }

  return -1 * (x.priority - y.priority);
}

